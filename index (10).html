<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebSocketèŠå¤©åº”ç”¨</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: '#4F46E5',
            secondary: '#7C3AED',
            accent: '#F59E0B',
            dark: '#1E293B',
            light: '#F8FAFC'
          },
          fontFamily: {
            inter: ['Inter', 'sans-serif'],
          },
        },
      }
    }
  </script>
  <style type="text/tailwindcss">
    @layer utilities {
      .content-auto {
        content-visibility: auto;
      }
      .scrollbar-hide {
        -ms-overflow-style: none;
        scrollbar-width: none;
      }
      .scrollbar-hide::-webkit-scrollbar {
        display: none;
      }
      .text-shadow {
        text-shadow: 0 2px 4px rgba(0,0,0,0.1);
      }
      .animate-float {
        animation: float 6s ease-in-out infinite;
      }
      @keyframes float {
        0% { transform: translateY(0px); }
        50% { transform: translateY(-10px); }
        100% { transform: translateY(0px); }
      }
      .message-options {
        opacity: 0;
        transition: opacity 0.2s ease;
      }
      .message-container:hover .message-options {
        opacity: 1;
      }
      .reaction {
        cursor: pointer;
        transition: transform 0.2s ease;
      }
      .reaction:hover {
        transform: scale(1.2);
      }
      .reaction.active {
        color: #4F46E5;
        font-weight: bold;
      }
      .message-reactions {
        margin-top: 4px;
        display: flex;
        gap: 8px;
        font-size: 12px;
        color: #6B7280;
      }
    }
  </style>
</head>
<body class="bg-gradient-to-br from-light to-gray-100 min-h-screen font-inter text-dark">
  <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
    <header class="mb-8">
      <div class="flex flex-col md:flex-row md:items-center justify-between gap-4">
        <div class="flex items-center">
          <div class="bg-primary text-white p-3 rounded-lg mr-3">
            <i class="fa fa-comments-o text-2xl"></i>
          </div>
          <h1 class="text-[clamp(1.75rem,3vw,2.5rem)] font-bold text-dark">
            WebSocket<span class="text-primary">èŠå¤©</span>åº”ç”¨
          </h1>
        </div>
        <div class="flex gap-3">
          <button id="startServerBtn" class="bg-primary hover:bg-primary/90 text-white px-5 py-2 rounded-lg transition-all duration-300 flex items-center shadow-lg hover:shadow-primary/30 hover:-translate-y-0.5">
            <i class="fa fa-play mr-2"></i> å¯åŠ¨æœåŠ¡å™¨
          </button>
          <button id="stopServerBtn" class="bg-red-500 hover:bg-red-600 text-white px-5 py-2 rounded-lg transition-all duration-300 flex items-center shadow-lg hover:shadow-red-500/30 hover:-translate-y-0.5" disabled>
            <i class="fa fa-stop mr-2"></i> åœæ­¢æœåŠ¡å™¨
          </button>
        </div>
      </div>
    </header>

    <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
      <!-- æœåŠ¡å™¨çŠ¶æ€é¢æ¿ -->
      <div class="lg:col-span-1">
        <div class="bg-white rounded-xl shadow-xl overflow-hidden transition-all duration-300 hover:shadow-2xl">
          <div class="bg-primary text-white p-4">
            <h2 class="text-xl font-bold flex items-center">
              <i class="fa fa-server mr-2"></i> æœåŠ¡å™¨çŠ¶æ€
            </h2>
          </div>
          <div class="p-5">
            <div class="space-y-4">
              <div>
                <div class="text-sm text-gray-500 mb-1">æœåŠ¡å™¨åœ°å€</div>
                <div class="flex items-center">
                  <input type="text" id="serverAddress" class="w-full bg-gray-100 border border-gray-200 rounded-lg px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-primary/50" value="ws://localhost:8080">
                  <button id="copyAddressBtn" class="ml-2 text-primary hover:text-primary/80 transition-colors">
                    <i class="fa fa-copy"></i>
                  </button>
                </div>
              </div>
              
              <div>
                <div class="text-sm text-gray-500 mb-1">å½“å‰çŠ¶æ€</div>
                <div id="serverStatus" class="bg-gray-100 rounded-lg px-3 py-2 text-sm font-medium text-gray-600">
                  æœªå¯åŠ¨
                </div>
              </div>
              
              <div>
                <div class="text-sm text-gray-500 mb-1">è¿æ¥æ•°</div>
                <div id="connectionCount" class="bg-gray-100 rounded-lg px-3 py-2 text-sm font-medium text-gray-600">
                  0
                </div>
              </div>
              
              <div>
                <div class="text-sm text-gray-500 mb-1">ç”¨æˆ·å</div>
                <div class="flex">
                  <input type="text" id="userName" placeholder="è®¾ç½®ç”¨æˆ·å" class="flex-1 bg-gray-100 border border-gray-200 rounded-l-lg px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-primary/50" value="ç”¨æˆ·">
                  <button id="setUserNameBtn" class="bg-primary text-white px-3 py-2 rounded-r-lg hover:bg-primary/90 transition-colors">
                    <i class="fa fa-check"></i>
                  </button>
                </div>
              </div>
              
              <div>
                <div class="text-sm text-gray-500 mb-1">å±è”½è¯åˆ—è¡¨</div>
                <div class="space-y-2">
                  <div id="blockedWordsList" class="bg-gray-100 rounded-lg p-3 max-h-32 overflow-y-auto scrollbar-hide text-sm">
                    <div class="text-gray-500 italic">æš‚æ— å±è”½è¯</div>
                  </div>
                  <div class="flex">
                    <input type="text" id="newBlockedWord" placeholder="æ·»åŠ å±è”½è¯" class="flex-1 bg-gray-100 border border-gray-200 rounded-l-lg px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-primary/50">
                    <button id="addBlockedWordBtn" class="bg-primary text-white px-3 py-2 rounded-r-lg hover:bg-primary/90 transition-colors">
                      <i class="fa fa-plus"></i>
                    </button>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      
      <!-- èŠå¤©é¢æ¿ -->
      <div class="lg:col-span-2">
        <div class="bg-white rounded-xl shadow-xl overflow-hidden h-[550px] flex flex-col transition-all duration-300 hover:shadow-2xl">
          <div class="bg-primary text-white p-4">
            <h2 class="text-xl font-bold flex items-center">
              <i class="fa fa-comments mr-2"></i> èŠå¤©åŒºåŸŸ
            </h2>
          </div>
          <div id="chatMessages" class="flex-1 p-5 overflow-y-auto scrollbar-hide space-y-4">
            <div class="text-center py-10">
              <div class="animate-float inline-block">
                <div class="w-16 h-16 bg-primary/10 rounded-full flex items-center justify-center mb-4">
                  <i class="fa fa-comments-o text-2xl text-primary"></i>
                </div>
              </div>
              <p class="text-gray-500 mt-2">å¯åŠ¨æœåŠ¡å™¨å¹¶å‘é€ç¬¬ä¸€æ¡æ¶ˆæ¯</p>
            </div>
          </div>
          <div class="border-t border-gray-200 p-4">
            <div class="flex gap-2">
              <input type="text" id="messageInput" placeholder="è¾“å…¥æ¶ˆæ¯..." class="flex-1 bg-gray-100 border border-gray-200 rounded-lg px-4 py-3 focus:outline-none focus:ring-2 focus:ring-primary/50">
              <button id="sendMessageBtn" class="bg-primary hover:bg-primary/90 text-white px-5 py-3 rounded-lg transition-all duration-300 flex items-center shadow-lg hover:shadow-primary/30 hover:-translate-y-0.5 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                <i class="fa fa-paper-plane mr-2"></i> å‘é€
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- æ—¥å¿—é¢æ¿ -->
    <div class="mt-8">
      <div class="bg-white rounded-xl shadow-xl overflow-hidden transition-all duration-300 hover:shadow-2xl">
        <div class="bg-secondary text-white p-4 flex justify-between items-center">
          <h2 class="text-xl font-bold flex items-center">
            <i class="fa fa-terminal mr-2"></i> æœåŠ¡å™¨æ—¥å¿—
          </h2>
          <button id="clearLogBtn" class="text-white/80 hover:text-white transition-colors">
            <i class="fa fa-trash"></i>
          </button>
        </div>
        <div class="p-5">
          <div id="serverLog" class="bg-gray-900 text-gray-200 rounded-lg p-4 font-mono text-sm h-40 overflow-y-auto scrollbar-hide">
            <div class="text-gray-400">ç­‰å¾…æœåŠ¡å™¨å¯åŠ¨...</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <footer class="mt-12 py-6 border-t border-gray-200">
    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
      <div class="flex flex-col md:flex-row md:justify-between md:items-center">
        <p class="text-gray-500 text-sm">Â© 2025 WebSocketèŠå¤©åº”ç”¨ | å®æ—¶é€šä¿¡æ¼”ç¤º</p>
        <div class="flex gap-4 mt-4 md:mt-0">
          <a href="#" class="text-gray-400 hover:text-primary transition-colors">
            <i class="fa fa-github"></i>
          </a>
          <a href="#" class="text-gray-400 hover:text-primary transition-colors">
            <i class="fa fa-twitter"></i>
          </a>
          <a href="#" class="text-gray-400 hover:text-primary transition-colors">
            <i class="fa fa-linkedin"></i>
          </a>
        </div>
      </div>
    </div>
  </footer>

  <script>
    // æ¶ˆæ¯IDç”Ÿæˆå™¨
    let messageIdCounter = 0;
    function generateMessageId() {
      return `msg-${Date.now()}-${messageIdCounter++}`;
    }
    
    // æœåŠ¡å™¨ç«¯WebSocketå®ç°
    class WebSocketServer {
      constructor() {
        this.server = null;
        this.clients = new Set();
        this.blockedWords = new Set(['sb', 'fuck', 'shit', 'bitch']);
        this.port = 8080;
        this.clientHandlers = [];
      }
      
      start() {
        if (this.server) {
          return Promise.reject(new Error('æœåŠ¡å™¨å·²åœ¨è¿è¡Œ'));
        }
        
        return new Promise((resolve, reject) => {
          try {
            // ä½¿ç”¨æµè§ˆå™¨çš„WebSocket APIæ¨¡æ‹ŸæœåŠ¡å™¨
            // æ³¨æ„ï¼šåœ¨å®é™…ç”Ÿäº§ç¯å¢ƒä¸­ï¼Œåº”ä½¿ç”¨Node.jsçš„wsåº“
            this.server = {
              clients: new Set(),
              on: (event, callback) => {
                // æ¨¡æ‹Ÿäº‹ä»¶ç›‘å¬
                if (event === 'connection') {
                  this._connectionCallback = callback;
                } else if (event === 'message') {
                  this._messageCallback = callback;
                }
              },
              close: () => {
                this.server = null;
                this.clients.clear();
                this._log('æœåŠ¡å™¨å·²åœæ­¢');
              }
            };
            
            // æ¨¡æ‹Ÿå®¢æˆ·ç«¯è¿æ¥
            setTimeout(() => {
              if (this._connectionCallback) {
                // åˆ›å»ºæ¨¡æ‹Ÿå®¢æˆ·ç«¯
                const client = {
                  id: Date.now(),
                  send: (data) => {
                    // è§¦å‘å®¢æˆ·ç«¯çš„onmessageäº‹ä»¶
                    this.clientHandlers.forEach(handler => {
                      if (handler && typeof handler === 'function') {
                        handler({ data });
                      }
                    });
                    this._log(`å‘å®¢æˆ·ç«¯ ${client.id} å‘é€æ¶ˆæ¯: ${data}`);
                  },
                  close: () => {
                    this.server.clients.delete(client);
                    if (this._closeCallback) {
                      this._closeCallback.call(client);
                    }
                    this._updateConnectionCount();
                  },
                  onmessage: null
                };
                
                this.server.clients.add(client);
                this._connectionCallback.call(this.server, client);
                this._log(`æ–°å®¢æˆ·ç«¯ ${client.id} å·²è¿æ¥`);
                this._updateConnectionCount();
                
                // è®¾ç½®æ¶ˆæ¯å¤„ç†å‡½æ•°
                this._messageCallback = (message) => {
                  this._log(`æ”¶åˆ°æ¥è‡ªå®¢æˆ·ç«¯ ${client.id} çš„æ¶ˆæ¯: ${message}`);
                  this.broadcast(message);
                };
              }
              
              resolve();
            }, 500);
            
            this._log(`æœåŠ¡å™¨å·²å¯åŠ¨ï¼Œç›‘å¬ç«¯å£ ${this.port}`);
            this._updateStatus('è¿è¡Œä¸­');
          } catch (error) {
            this._log(`å¯åŠ¨æœåŠ¡å™¨å¤±è´¥: ${error.message}`);
            reject(error);
          }
        });
      }
      
      stop() {
        if (!this.server) {
          return Promise.reject(new Error('æœåŠ¡å™¨æœªè¿è¡Œ'));
        }
        
        return new Promise((resolve) => {
          try {
            // å…³é—­æ‰€æœ‰å®¢æˆ·ç«¯è¿æ¥
            this.server.clients.forEach(client => client.close());
            
            // å…³é—­æœåŠ¡å™¨
            this.server.close();
            this.server = null;
            this._updateStatus('æœªå¯åŠ¨');
            this._updateConnectionCount();
            resolve();
          } catch (error) {
            this._log(`åœæ­¢æœåŠ¡å™¨å¤±è´¥: ${error.message}`);
            resolve(); // å³ä½¿å‡ºé”™ä¹Ÿè®¤ä¸ºåœæ­¢æ“ä½œå®Œæˆ
          }
        });
      }
      
      broadcast(message) {
        if (!this.server) {
          return;
        }
        
        // æ£€æŸ¥å¹¶è¿‡æ»¤å±è”½è¯
        const filteredMessage = this._filterMessage(message);
        
        // å¹¿æ’­æ¶ˆæ¯ç»™æ‰€æœ‰å®¢æˆ·ç«¯
        this.server.clients.forEach(client => {
          try {
            // æ·»åŠ æ¶ˆæ¯ID
            const messageWithId = JSON.stringify({
              id: generateMessageId(),
              content: filteredMessage
            });
            client.send(messageWithId);
          } catch (error) {
            this._log(`å‘é€æ¶ˆæ¯å¤±è´¥: ${error.message}`);
          }
        });
        
        this._log(`å¹¿æ’­æ¶ˆæ¯: ${filteredMessage}`);
      }
      
      addBlockedWord(word) {
        if (word && !this.blockedWords.has(word.toLowerCase())) {
          this.blockedWords.add(word.toLowerCase());
          this._updateBlockedWordsList();
          this._log(`æ·»åŠ å±è”½è¯: ${word}`);
          return true;
        }
        return false;
      }
      
      removeBlockedWord(word) {
        if (this.blockedWords.has(word.toLowerCase())) {
          this.blockedWords.delete(word.toLowerCase());
          this._updateBlockedWordsList();
          this._log(`ç§»é™¤å±è”½è¯: ${word}`);
          return true;
        }
        return false;
      }
      
      registerClientHandler(handler) {
        this.clientHandlers.push(handler);
      }
      
      _filterMessage(message) {
        let filtered = message;
        this.blockedWords.forEach(word => {
          const regex = new RegExp(`\\b${word}\\b`, 'gi');
          filtered = filtered.replace(regex, this._getReplacement(word.length));
        });
        return filtered;
      }
      
      _getReplacement(length) {
        return '*'.repeat(length);
      }
      
      _log(message) {
        const logElement = document.getElementById('serverLog');
        const timestamp = new Date().toLocaleTimeString();
        const logEntry = document.createElement('div');
        logEntry.className = 'mb-1';
        logEntry.innerHTML = `<span class="text-gray-400">${timestamp}</span> <span class="text-white">${message}</span>`;
        logElement.appendChild(logEntry);
        logElement.scrollTop = logElement.scrollHeight;
      }
      
      _updateStatus(status) {
        const statusElement = document.getElementById('serverStatus');
        statusElement.textContent = status;
        
        if (status === 'è¿è¡Œä¸­') {
          statusElement.className = 'bg-green-100 text-green-800 rounded-lg px-3 py-2 text-sm font-medium';
        } else {
          statusElement.className = 'bg-gray-100 text-gray-600 rounded-lg px-3 py-2 text-sm font-medium';
        }
      }
      
      _updateConnectionCount() {
        const countElement = document.getElementById('connectionCount');
        countElement.textContent = this.server ? this.server.clients.size : '0';
      }
      
      _updateBlockedWordsList() {
        const listElement = document.getElementById('blockedWordsList');
        listElement.innerHTML = '';
        
        if (this.blockedWords.size === 0) {
          const emptyItem = document.createElement('div');
          emptyItem.className = 'text-gray-500 italic';
          emptyItem.textContent = 'æš‚æ— å±è”½è¯';
          listElement.appendChild(emptyItem);
          return;
        }
        
        this.blockedWords.forEach(word => {
          const item = document.createElement('div');
          item.className = 'flex justify-between items-center mb-1';
          item.innerHTML = `
            <span class="bg-gray-200 px-2 py-1 rounded">${word}</span>
            <button class="text-red-500 hover:text-red-700 remove-word" data-word="${word}">
              <i class="fa fa-times"></i>
            </button>
          `;
          listElement.appendChild(item);
        });
        
        // æ·»åŠ åˆ é™¤äº‹ä»¶ç›‘å¬
        document.querySelectorAll('.remove-word').forEach(button => {
          button.addEventListener('click', (e) => {
            const word = e.currentTarget.getAttribute('data-word');
            this.removeBlockedWord(word);
          });
        });
      }
    }
    
    // å®¢æˆ·ç«¯WebSocketå®ç°
    class WebSocketClient {
      constructor(serverAddress, server) {
        this.socket = null;
        this.serverAddress = serverAddress;
        this.server = server;
        this.messageHandler = null;
        this.statusHandler = null;
        this.isConnected = false;
        this.userName = 'ç”¨æˆ·';
        this.reactions = new Map(); // å­˜å‚¨æ¶ˆæ¯IDå’Œç”¨æˆ·ååº”çš„æ˜ å°„
      }
      
      connect() {
        return new Promise((resolve, reject) => {
          try {
            // ç”±äºæµè§ˆå™¨å®‰å…¨é™åˆ¶ï¼Œæ— æ³•çœŸæ­£åˆ›å»ºWebSocketæœåŠ¡å™¨
            // è¿™é‡Œä½¿ç”¨æ¨¡æ‹Ÿçš„æ–¹å¼ä¸æˆ‘ä»¬çš„"æœåŠ¡å™¨"é€šä¿¡
            if (this.server) {
              // æ³¨å†Œæ¶ˆæ¯å¤„ç†å‡½æ•°
              this.server.registerClientHandler((event) => {
                if (this.messageHandler) {
                  try {
                    const messageData = JSON.parse(event.data);
                    this.messageHandler(messageData);
                  } catch (e) {
                    // å¦‚æœè§£æå¤±è´¥ï¼Œä½¿ç”¨åŸå§‹æ¶ˆæ¯
                    this.messageHandler({ id: generateMessageId(), content: event.data });
                  }
                }
              });
              
              this.isConnected = true;
              this._updateStatus('å·²è¿æ¥');
              this._log('è¿æ¥æˆåŠŸ');
              resolve();
            } else {
              this._log('æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨: æœåŠ¡å™¨æœªåˆå§‹åŒ–');
              reject(new Error('æœåŠ¡å™¨æœªåˆå§‹åŒ–'));
            }
          } catch (error) {
            this._log(`åˆ›å»ºè¿æ¥å¤±è´¥: ${error.message}`);
            reject(error);
          }
        });
      }
      
      disconnect() {
        this.isConnected = false;
        this._updateStatus('æœªè¿æ¥');
        this._log('è¿æ¥å·²å…³é—­');
      }
      
      send(message) {
        if (this.isConnected && this.server && this.server.server) {
          // ç›´æ¥è°ƒç”¨æœåŠ¡å™¨çš„æ¶ˆæ¯å¤„ç†å‡½æ•°ï¼Œå¸¦ä¸Šç”¨æˆ·å
          if (this.server._messageCallback) {
            this.server._messageCallback(`${this.userName}: ${message}`);
          }
          this._log(`å‘é€æ¶ˆæ¯: ${message}`);
        }
      }
      
      setUserName(name) {
        this.userName = name;
        this._log(`ç”¨æˆ·åå·²è®¾ç½®ä¸º: ${name}`);
        return name;
      }
      
      reactToMessage(messageId, reaction) {
        this.reactions.set(messageId, reaction);
        // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™é‡Œåº”è¯¥å‘é€ååº”åˆ°æœåŠ¡å™¨
        this._log(`å¯¹æ¶ˆæ¯ ${messageId} æ·»åŠ äº†ååº”: ${reaction}`);
      }
      
      onMessage(handler) {
        this.messageHandler = handler;
      }
      
      onStatusChange(handler) {
        this.statusHandler = handler;
      }
      
      _updateStatus(status) {
        if (this.statusHandler) {
          this.statusHandler(status);
        }
      }
      
      _log(message) {
        console.log(`[WebSocketClient] ${message}`);
      }
    }
    
    // åº”ç”¨é€»è¾‘
    document.addEventListener('DOMContentLoaded', () => {
      const server = new WebSocketServer();
      let client = null;
      
      // å…ƒç´ å¼•ç”¨
      const startServerBtn = document.getElementById('startServerBtn');
      const stopServerBtn = document.getElementById('stopServerBtn');
      const serverAddress = document.getElementById('serverAddress');
      const copyAddressBtn = document.getElementById('copyAddressBtn');
      const messageInput = document.getElementById('messageInput');
      const sendMessageBtn = document.getElementById('sendMessageBtn');
      const newBlockedWord = document.getElementById('newBlockedWord');
      const addBlockedWordBtn = document.getElementById('addBlockedWordBtn');
      const clearLogBtn = document.getElementById('clearLogBtn');
      const chatMessages = document.getElementById('chatMessages');
      const userNameInput = document.getElementById('userName');
      const setUserNameBtn = document.getElementById('setUserNameBtn');
      
      // åˆå§‹åŒ–å±è”½è¯åˆ—è¡¨
      server._updateBlockedWordsList();
      
      // è®¾ç½®ç”¨æˆ·å
      setUserNameBtn.addEventListener('click', () => {
        const name = userNameInput.value.trim() || 'ç”¨æˆ·';
        if (client) {
          client.setUserName(name);
          addMessageToChat('ç³»ç»Ÿ', `ä½ çš„ç”¨æˆ·åå·²è®¾ç½®ä¸º: ${name}`);
        }
      });
      
      // å¯åŠ¨æœåŠ¡å™¨
      startServerBtn.addEventListener('click', async () => {
        try {
          await server.start();
          
          // æ›´æ–°UIçŠ¶æ€
          startServerBtn.disabled = true;
          stopServerBtn.disabled = false;
          sendMessageBtn.disabled = false;
          
          // åˆ›å»ºå®¢æˆ·ç«¯è¿æ¥
          const address = serverAddress.value;
          client = new WebSocketClient(address, server);
          
          // è®¾ç½®åˆå§‹ç”¨æˆ·å
          client.setUserName(userNameInput.value.trim() || 'ç”¨æˆ·');
          
          client.onMessage((messageData) => {
            addMessageToChat('æœåŠ¡å™¨', messageData.content, messageData.id);
          });
          
          client.onStatusChange((status) => {
            console.log(`å®¢æˆ·ç«¯çŠ¶æ€: ${status}`);
          });
          
          await client.connect();
          addMessageToChat('ç³»ç»Ÿ', 'å·²è¿æ¥åˆ°æœåŠ¡å™¨');
        } catch (error) {
          console.error('å¯åŠ¨æœåŠ¡å™¨å¤±è´¥:', error);
        }
      });
      
      // åœæ­¢æœåŠ¡å™¨
      stopServerBtn.addEventListener('click', async () => {
        try {
          if (client) {
            client.disconnect();
            client = null;
          }
          
          await server.stop();
          
          // æ›´æ–°UIçŠ¶æ€
          startServerBtn.disabled = false;
          stopServerBtn.disabled = true;
          sendMessageBtn.disabled = true;
          
          addMessageToChat('ç³»ç»Ÿ', 'æœåŠ¡å™¨å·²åœæ­¢');
        } catch (error) {
          console.error('åœæ­¢æœåŠ¡å™¨å¤±è´¥:', error);
        }
      });
      
      // å¤åˆ¶æœåŠ¡å™¨åœ°å€
      copyAddressBtn.addEventListener('click', () => {
        serverAddress.select();
        document.execCommand('copy');
        
        // æ˜¾ç¤ºå¤åˆ¶æˆåŠŸæç¤º
        const originalText = copyAddressBtn.innerHTML;
        copyAddressBtn.innerHTML = '<i class="fa fa-check"></i>';
        setTimeout(() => {
          copyAddressBtn.innerHTML = originalText;
        }, 1500);
      });
      
      // å‘é€æ¶ˆæ¯
      sendMessageBtn.addEventListener('click', sendMessage);
      messageInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          sendMessage();
        }
      });
      
      // æ·»åŠ å±è”½è¯
      addBlockedWordBtn.addEventListener('click', () => {
        const word = newBlockedWord.value.trim().toLowerCase();
        if (word) {
          server.addBlockedWord(word);
          newBlockedWord.value = '';
        }
      });
      
      // æŒ‰å›è½¦æ·»åŠ å±è”½è¯
      newBlockedWord.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          addBlockedWordBtn.click();
        }
      });
      
      // æ¸…ç©ºæ—¥å¿—
      clearLogBtn.addEventListener('click', () => {
        document.getElementById('serverLog').innerHTML = '';
      });
      
      // å‘é€æ¶ˆæ¯å‡½æ•°
      function sendMessage() {
        const message = messageInput.value.trim();
        if (message && client && client.isConnected) {
          const messageId = generateMessageId();
          addMessageToChat(client.userName, message, messageId, true);
          client.send(message);
          messageInput.value = '';
        }
      }
      
      // æ·»åŠ æ¶ˆæ¯åˆ°èŠå¤©åŒºåŸŸ
      function addMessageToChat(sender, message, messageId, isSelf = false) {
        const messageElement = document.createElement('div');
        messageElement.className = 'message-container flex items-start mb-4';
        messageElement.dataset.messageId = messageId;
        
        // æå–å®é™…å‘é€è€…åç§°å’Œæ¶ˆæ¯å†…å®¹
        let displaySender = sender;
        let displayMessage = message;
        
        if (sender === 'æœåŠ¡å™¨') {
          const match = message.match(/^([^:]+): (.*)$/);
          if (match) {
            displaySender = match[1];
            displayMessage = match[2];
          }
        }
        
        // åˆ¤æ–­æ˜¯å¦æ˜¯è‡ªå·±çš„æ¶ˆæ¯
        const isOwnMessage = isSelf || (client && displaySender === client.userName);
        
        if (isOwnMessage) {
          messageElement.className += ' justify-end';
          messageElement.innerHTML = `
            <div class="bg-primary text-white rounded-lg rounded-tr-none p-3 max-w-[80%] shadow-lg relative">
              <div class="font-medium mb-1">${displaySender}</div>
              <div class="break-words">${displayMessage}</div>
              <div class="message-options absolute -bottom-6 right-0 flex gap-2 bg-white text-gray-500 rounded-full px-2 py-1 shadow-md">
                <button class="retract-btn text-red-500 hover:text-red-700" title="æ’¤å›">
                  <i class="fa fa-undo"></i>
                </button>
              </div>
              <div class="message-reactions"></div>
            </div>
            <div class="w-8 h-8 bg-primary/20 rounded-full flex items-center justify-center text-primary ml-2">
              <i class="fa fa-user"></i>
            </div>
          `;
        } else {
          messageElement.innerHTML = `
            <div class="w-8 h-8 bg-gray-200 rounded-full flex items-center justify-center text-gray-600 mr-2">
              <i class="fa fa-user"></i>
            </div>
            <div class="bg-white border border-gray-200 rounded-lg rounded-tl-none p-3 max-w-[80%] shadow-md relative">
              <div class="font-medium text-primary mb-1">${displaySender}</div>
              <div class="break-words">${displayMessage}</div>
              <div class="message-options absolute -bottom-6 left-0 flex gap-2 bg-white text-gray-500 rounded-full px-2 py-1 shadow-md">
                <button class="reaction-btn" data-reaction="ğŸ‘" title="èµ">ğŸ‘</button>
                <button class="reaction-btn" data-reaction="â¤" title="å–œæ¬¢">â¤</button>
                <button class="reaction-btn" data-reaction="ğŸ’©" title="è¿™ä¸æ˜¯ä¸€å¨å—">ğŸ’©</button>
                <button class="reaction-btn" data-reaction="â" title="ä¸æ˜¾ç¤º">â</button>
              </div>
              <div class="message-reactions"></div>
            </div>
          `;
        }
        
        chatMessages.appendChild(messageElement);
        chatMessages.scrollTop = chatMessages.scrollHeight;
        
        // æ·»åŠ æ¶ˆæ¯äº¤äº’äº‹ä»¶
        if (isOwnMessage) {
          // è‡ªå·±çš„æ¶ˆæ¯å¯ä»¥æ’¤å›
          const retractBtn = messageElement.querySelector('.retract-btn');
          if (retractBtn) {
            retractBtn.addEventListener('click', () => {
              retractMessage(messageId);
            });
          }
        } else {
          // ä»–äººæ¶ˆæ¯å¯ä»¥æ·»åŠ ååº”
          const reactionBtns = messageElement.querySelectorAll('.reaction-btn');
          reactionBtns.forEach(btn => {
            btn.addEventListener('click', (e) => {
              const reaction = e.currentTarget.getAttribute('data-reaction');
              addReactionToMessage(messageId, reaction, messageElement);
            });
          });
        }
      }
      
      // æ’¤å›æ¶ˆæ¯
      function retractMessage(messageId) {
        const messageElement = document.querySelector(`.message-container[data-messageId="${messageId}"]`);
        if (messageElement) {
          // è·å–æ¶ˆæ¯å†…å®¹
          const messageContent = messageElement.querySelector('.break-words').textContent;
          
          // æ›¿æ¢ä¸ºæ’¤å›æç¤º
          messageElement.querySelector('.break-words').innerHTML = '<span class="text-gray-400 italic">ä½ æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯</span>';
          
          // éšè—é€‰é¡¹æŒ‰é’®
          const options = messageElement.querySelector('.message-options');
          if (options) options.style.display = 'none';
          
          // è®°å½•åˆ°æœåŠ¡å™¨æ—¥å¿—
          server._log(`ç”¨æˆ·æ’¤å›äº†æ¶ˆæ¯: ${messageContent}`);
        }
      }
      
      // æ·»åŠ ååº”åˆ°æ¶ˆæ¯
      function addReactionToMessage(messageId, reaction, messageElement) {
        if (!messageElement) {
          messageElement = document.querySelector(`.message-container[data-messageId="${messageId}"]`);
        }
        
        if (messageElement) {
          // ä¿å­˜ååº”
          if (client) {
            client.reactToMessage(messageId, reaction);
          }
          
          // æ›´æ–°UI
          const reactionsContainer = messageElement.querySelector('.message-reactions');
          if (reactionsContainer) {
            // æŸ¥æ‰¾æ˜¯å¦å·²æœ‰è¯¥ååº”
            let reactionElement = reactionsContainer.querySelector(`.reaction[data-reaction="${reaction}"]`);
            
            if (reactionElement) {
              // å¦‚æœå·²æœ‰ååº”ï¼Œå¢åŠ è®¡æ•°
              const countElement = reactionElement.querySelector('.count');
              let count = parseInt(countElement.textContent) || 1;
              countElement.textContent = count + 1;
              
              // æ·»åŠ åŠ¨ç”»æ•ˆæœ
              reactionElement.classList.add('animate-pulse');
              setTimeout(() => {
                reactionElement.classList.remove('animate-pulse');
              }, 500);
            } else {
              // åˆ›å»ºæ–°çš„ååº”å…ƒç´ 
              reactionElement = document.createElement('div');
              reactionElement.className = 'reaction flex items-center gap-1';
              reactionElement.dataset.reaction = reaction;
              reactionElement.innerHTML = `
                <span>${reaction}</span>
                <span class="count">1</span>
              `;
              reactionsContainer.appendChild(reactionElement);
            }
            
            // å¦‚æœæ˜¯"ä¸æ˜¾ç¤º"ååº”ï¼Œéšè—æ¶ˆæ¯
            if (reaction === 'â') {
              setTimeout(() => {
                messageElement.style.opacity = '0.3';
                messageElement.style.pointerEvents = 'none';
              }, 500);
            }
          }
        }
      }
    });
  </script>
</body>
</html>
    